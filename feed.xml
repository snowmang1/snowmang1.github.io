<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://snowmang1.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://snowmang1.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-07T00:26:34+00:00</updated><id>https://snowmang1.github.io/feed.xml</id><title type="html">Evan M. Drake</title><subtitle>This is a kind of blog that will just allow me to write (short form) on my personal projects </subtitle><entry><title type="html">Inversion Operation</title><link href="https://snowmang1.github.io/blog/2025/inversion_op/" rel="alternate" type="text/html" title="Inversion Operation"/><published>2025-01-30T00:00:00+00:00</published><updated>2025-01-30T00:00:00+00:00</updated><id>https://snowmang1.github.io/blog/2025/inversion_op</id><content type="html" xml:base="https://snowmang1.github.io/blog/2025/inversion_op/"><![CDATA[<h1 id="introduction--hypothesis">Introduction / Hypothesis</h1> <p>For the past couple of months I have been fixated on learning the field of topology as a kind of hobby. In that time the use of inverse function $f^-1$ has caught my eye. This kind of notation is seen often to describe the inverse of a function $f$, especially in <d-cite key="munkres_topo"></d-cite>. I became curious whether this kind of operation was as automatic in computer science. My favorite languages these days being: Lean4 and Haskell I have gotten all to use to maths being built into a language. As it turns out things like inversion functions are not common in CS at least not <em>automatic inversabilty</em> as seen in the notation $f^-1$. It may be unclear what I mean by automatic inversabilty at this point, I will go into detail later. There is a literature examining this very topic and I read some of those papers which I will again discuss below. Once I found that this topic was not common enough to have been widely addressed in the non-academic space I got curious about difficulty. How hard could it be to create a system within a compiler that could, in theory take any function and give you its inverse. This is where I started of course I found that it could be incredibly difficult. My hypothesis was simple, I needed to create a program that could create an inverse function automatically while limiting the resources to simulate that of a simple compiler. I decided to limit myself to a basic AST structure that kept no real metadata but simply the lexemes and some type information. That was the structure that would take and create an inverse function with, I weakened my initial statement and assumed an interpreted language so that I could still use Haskell for the experiment. I felt it may take longer than I would like if I used something else (and Haskell is so fun to use so I thought). Some basic pseudocode I drew up for the project before starting.</p> <d-code> Node : Operation or Lexeme AST : Node [] -- where the AST is a tree with node equal to an operation or lexeme f : AST -&gt; AST f (node []) = invert node -- leaf case f (node ls) = AST (invert node) (map f ls) -- f would invert the AST meaning to take the inverse of each piece recursively -- assume that the inverse of any AST is the inverse of its parts </d-code> <p>I have some initial problems with this approach. First simply mapping $f$ over all children is begging for a stack overflow. Secondly is my assumption that the inverse of any function body AST (thus the inverse of any function) is constructed via the inverse of its parts? I convinced myself that speed optimization could wait until after I had seen if the idea could work. The assumption did have me worried, thus I constrained the math to arithmetic where I found only edge cases where my assumption was untrue. The edge cases though difficult to ignore can be countered with constraints. Our problem space is currently bound by the following.</p> <p>\begin{equation} \text{Assumption 1: } AST^{-1} = [x \in AST | \sum x_i^{-1}] \end{equation}</p> <p>\begin{equation} \text{Assumption 2: Arithmetic space only} \end{equation}</p> <hr/> <h1 id="literature">Literature</h1> <hr/> <h1 id="implementation">Implementation</h1> <hr/> <h1 id="problems-with-the-initial-setup">Problems with the initial setup</h1>]]></content><author><name>Evan Drake</name></author><category term="compilers"/><category term="programming"/><summary type="html"><![CDATA[article about a simple arithmetic inversion operation utilizing a standard AST]]></summary></entry></feed>